---
date created: 星期五, 五月 31日 2024, 3:26:14 下午
date modified: 星期三, 六月 5日 2024, 8:25:32 晚上
tags: 
---

# 3e1-互斥与自旋锁

互斥与自旋锁加锁成功后都是排他的，当某个线程加锁成功后，其他线程就会失败。互斥与自旋的区别在于加锁失败后的行为不一样：

- 互斥锁：加锁失败后，线程进入阻塞状态，CPU被释放。
- 自旋锁：加锁失败后，线程进入忙等待，CPU一直被占用。

## 互斥锁

当尝试获取互斥锁失败后，CPU会被释放，线程进入到阻塞状态，等到锁被释放后，线程会被唤醒。这一过程中的线程状态变化是由操作系统[[1-内核]]实现的，提到内核，那必然涉及到用户态与内核态的切换，因此互斥锁存在两次上线文切换的开销成本，一次是加锁失败，陷入内核态切换其他线程，另一次是锁释放，陷入内核态切换回线程。

因此当锁住的代码执行时间比较短的话，可能还没有上下文切换的耗时久。

## 自旋锁

当一个线程尝试获取锁时，锁已经被其他线程持有，此时该线程会在循环中反复检查锁是否已经释放，这个过程称为”自旋“。整个过程不牵扯到线程的切换，因此开销会小一些。

CPU一般会提供`CAS`指令，实现原子的检查 + 占锁。

## 使用场景

当占锁的执行时间比较长时，适合使用互斥锁，不会造成CPU的资源浪费。
当占锁的执行时间非常短时，适合使用自旋锁，避免主动触发的线程切换带来的成本。